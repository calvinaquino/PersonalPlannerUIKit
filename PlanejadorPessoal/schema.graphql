# The Any scalar type
 is used in operations and types that involve any type of value.
scalar Any

# Use Inline Fragment on Array to get results: https://graphql.org/learn/queries/#inline-fragments
union ArrayResult =
    Element
  | Role
  | User
  | BudgetCategory
  | ShoppingCategory
  | ShoppingItem
  | TransactionItem
# The ArrayWhereInput input type is used in operations that involve filtering objects by a field of type Array.
input ArrayWhereInput {
  # This is the equalTo operator to specify a constraint to select the objects
  # where the value of a field equals to a specified value.
  equalTo: Any
  # This is the notEqualTo operator to specify a constraint to select the objects
  # where the value of a field do not equal to a specified value.
  notEqualTo: Any
  # This is the lessThan operator to specify a constraint to select the objects
  # where the value of a field is less than a specified value.
  lessThan: Any
  # This is the lessThanOrEqualTo operator to specify a constraint to select the
  # objects where the value of a field is less than or equal to a specified value.
  lessThanOrEqualTo: Any
  # This is the greaterThan operator to specify a constraint to select the objects
  # where the value of a field is greater than a specified value.
  greaterThan: Any
  # This is the greaterThanOrEqualTo operator to specify a constraint to select
  # the objects where the value of a field is greater than or equal to a specified value.
  greaterThanOrEqualTo: Any
  # This is the in operator to specify a constraint to select the objects where
  # the value of a field equals any value in the specified array.
  in: [Any]
  # This is the notIn operator to specify a constraint to select the objects where
  # the value of a field do not equal any value in the specified array.
  notIn: [Any]
  # This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist).
  exists: Boolean
  # This is the inQueryKey operator to specify a constraint to select the objects
  # where a field equals to a key in the result of a different query.
  inQueryKey: SelectInput
  # This is the notInQueryKey operator to specify a constraint to select the
  # objects where a field do not equal to a key in the result of a different query.
  notInQueryKey: SelectInput
  # This is the containedBy operator to specify a constraint to select the objects
  # where the values of an array field is contained by another specified array.
  containedBy: [Any]
  # This is the contains operator to specify a constraint to select the objects
  # where the values of an array field contain all elements of another specified array.
  contains: [Any]
}

# The BooleanWhereInput input type is used in operations that involve filtering objects by a field of type Boolean.
input BooleanWhereInput {
  # This is the equalTo operator to specify a constraint to select the objects
  # where the value of a field equals to a specified value.
  equalTo: Boolean
  # This is the notEqualTo operator to specify a constraint to select the objects
  # where the value of a field do not equal to a specified value.
  notEqualTo: Boolean
  # This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist).
  exists: Boolean
  # This is the inQueryKey operator to specify a constraint to select the objects
  # where a field equals to a key in the result of a different query.
  inQueryKey: SelectInput
  # This is the notInQueryKey operator to specify a constraint to select the
  # objects where a field do not equal to a key in the result of a different query.
  notInQueryKey: SelectInput
}

# The BoxInput type is used to specifiy a box operation on a within geo query.
input BoxInput {
  # This is the bottom left coordinates of the box.
  bottomLeft: GeoPointInput!
  # This is the upper right coordinates of the box.
  upperRight: GeoPointInput!
}

# The BudgetCategory object type is used in operations that involve outputting objects of BudgetCategory class.
type BudgetCategory implements ParseObject {
  # This is the object id.
  id: ID!
  # This is the date in which the object was created.
  createdAt: Date!
  # This is the date in which the object was las updated.
  updatedAt: Date!
  # This is the access control list of the object.
  ACL: Object
  # This is the object name.
  name: String
  # This is the object budget.
  budget: Float
}

# The BudgetCategoryFindResult object type is used in the BudgetCategory find query to return the data of the matched objects.
type BudgetCategoryFindResult {
  # This is the objects returned by the query
  results: [BudgetCategory!]!
  # This is the total matched objecs count that is returned when the count flag is set.
  count: Int!
}

# The BudgetCategoryOrder input type is used when sorting objects of the BudgetCategory class.
enum BudgetCategoryOrder {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  ACL_ASC
  ACL_DESC
  name_ASC
  name_DESC
  budget_ASC
  budget_DESC
  id_ASC
  id_DESC
}

# Allow to link OR add and link an object of the BudgetCategory class.
input BudgetCategoryPointerInput {
  # Link an existing object from BudgetCategory class.
  link: ID
  # Create and link an object from BudgetCategory class.
  createAndLink: CreateBudgetCategoryFieldsInput
}

# The BudgetCategoryPointerWhereInput input type is used in operations that
# involve filtering objects by a pointer field to BudgetCategory class.
input BudgetCategoryPointerWhereInput {
  # This is the equalTo operator to specify a constraint to select the objects
  # where the value of a field equals to a specified value.
  equalTo: ID
  # This is the notEqualTo operator to specify a constraint to select the objects
  # where the value of a field do not equal to a specified value.
  notEqualTo: ID
  # This is the in operator to specify a constraint to select the objects where
  # the value of a field equals any value in the specified array.
  in: [ID!]
  # This is the notIn operator to specify a constraint to select the objects where
  # the value of a field do not equal any value in the specified array.
  notIn: [ID!]
  # This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist).
  exists: Boolean
  # This is the inQueryKey operator to specify a constraint to select the objects
  # where a field equals to a key in the result of a different query.
  inQueryKey: SelectInput
  # This is the notInQueryKey operator to specify a constraint to select the
  # objects where a field do not equal to a key in the result of a different query.
  notInQueryKey: SelectInput
  # This is the inQuery operator to specify a constraint to select the objects
  # where a field equals to any of the ids in the result of a different query.
  inQuery: SubqueryInput
  # This is the notInQuery operator to specify a constraint to select the objects
  # where a field do not equal to any of the ids in the result of a different query.
  notInQuery: SubqueryInput
}

# Allow to add, remove, createAndAdd objects of the BudgetCategory class into a relation field.
input BudgetCategoryRelationInput {
  # Add an existing object from the BudgetCategory class into the relation.
  add: [ID!]
  # Remove an existing object from the BudgetCategory class out of the relation.
  remove: [ID!]
  # Create and add an object of the BudgetCategory class into the relation.
  createAndAdd: [CreateBudgetCategoryFieldsInput!]
}

# The BudgetCategoryWhereInput input type is used in operations that involve filtering objects of BudgetCategory class.
input BudgetCategoryWhereInput {
  # This is the object createdAt.
  createdAt: DateWhereInput
  # This is the object updatedAt.
  updatedAt: DateWhereInput
  # This is the object ACL.
  ACL: ObjectWhereInput
  # This is the object name.
  name: StringWhereInput
  # This is the object budget.
  budget: NumberWhereInput
  # This is the object id.
  id: StringWhereInput
  # This is the OR operator to compound constraints.
  OR: [BudgetCategoryWhereInput!]
  # This is the AND operator to compound constraints.
  AND: [BudgetCategoryWhereInput!]
  # This is the NOR operator to compound constraints.
  NOR: [BudgetCategoryWhereInput!]
}

# The Bytes scalar type
 is used in operations and types that involve base 64 binary data.
scalar Bytes

# The BytesWhereInput input type is used in operations that involve filtering objects by a field of type Bytes.
input BytesWhereInput {
  # This is the equalTo operator to specify a constraint to select the objects
  # where the value of a field equals to a specified value.
  equalTo: Bytes
  # This is the notEqualTo operator to specify a constraint to select the objects
  # where the value of a field do not equal to a specified value.
  notEqualTo: Bytes
  # This is the lessThan operator to specify a constraint to select the objects
  # where the value of a field is less than a specified value.
  lessThan: Bytes
  # This is the lessThanOrEqualTo operator to specify a constraint to select the
  # objects where the value of a field is less than or equal to a specified value.
  lessThanOrEqualTo: Bytes
  # This is the greaterThan operator to specify a constraint to select the objects
  # where the value of a field is greater than a specified value.
  greaterThan: Bytes
  # This is the greaterThanOrEqualTo operator to specify a constraint to select
  # the objects where the value of a field is greater than or equal to a specified value.
  greaterThanOrEqualTo: Bytes
  # This is the in operator to specify a constraint to select the objects where
  # the value of a field equals any value in the specified array.
  in: [Bytes]
  # This is the notIn operator to specify a constraint to select the objects where
  # the value of a field do not equal any value in the specified array.
  notIn: [Bytes]
  # This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist).
  exists: Boolean
  # This is the inQueryKey operator to specify a constraint to select the objects
  # where a field equals to a key in the result of a different query.
  inQueryKey: SelectInput
  # This is the notInQueryKey operator to specify a constraint to select the
  # objects where a field do not equal to a key in the result of a different query.
  notInQueryKey: SelectInput
}

# The CenterSphereInput type is used to specifiy a centerSphere operation on a geoWithin query.
input CenterSphereInput {
  # This is the center of the sphere.
  center: GeoPointInput!
  # This is the radius of the sphere.
  distance: Float!
}

# The Class type is used to return the information about an object class.
type Class {
  # This is the name of the object class.
  name: String!
  # These are the schema's fields of the object class.
  schemaFields: [SchemaField!]!
}

# The CreateBudgetCategoryFieldsInput input type is used in operations that
# involve creation of objects in the BudgetCategory class.
input CreateBudgetCategoryFieldsInput {
  # This is the access control list of the object.
  ACL: Object
  # This is the object name.
  name: String
  # This is the object budget.
  budget: Float
}

# The CreateRoleFieldsInput input type is used in operations that involve creation of objects in the Role class.
input CreateRoleFieldsInput {
  # This is the access control list of the object.
  ACL: Object
  # This is the object name.
  name: String
  # This is the object users.
  users: UserRelationInput
  # This is the object roles.
  roles: RoleRelationInput
}

# The CreateShoppingCategoryFieldsInput input type is used in operations that
# involve creation of objects in the ShoppingCategory class.
input CreateShoppingCategoryFieldsInput {
  # This is the access control list of the object.
  ACL: Object
  # This is the object name.
  name: String
}

# The CreateShoppingItemFieldsInput input type is used in operations that involve
# creation of objects in the ShoppingItem class.
input CreateShoppingItemFieldsInput {
  # This is the access control list of the object.
  ACL: Object
  # This is the object name.
  name: String
  # This is the object localizedName.
  localizedName: String
  # This is the object price.
  price: Float
  # This is the object isNeeded.
  isNeeded: Boolean
  # This is the object shoppingCategory.
  shoppingCategory: ShoppingCategoryPointerInput
}

# The CreateTransactionItemFieldsInput input type is used in operations that
# involve creation of objects in the TransactionItem class.
input CreateTransactionItemFieldsInput {
  # This is the access control list of the object.
  ACL: Object
  # This is the object name.
  name: String
  # This is the object value.
  value: Float
  # This is the object year.
  year: Float
  # This is the object month.
  month: Float
  # This is the object budgetCategory.
  budgetCategory: BudgetCategoryPointerInput
  # This is the object day.
  day: Float
  # This is the object location.
  location: String
}

# The CreateUserFieldsInput input type is used in operations that involve creation of objects in the User class.
input CreateUserFieldsInput {
  # This is the access control list of the object.
  ACL: Object
  # This is the object username.
  username: String
  # This is the object password.
  password: String
  # This is the object email.
  email: String
  # This is the object emailVerified.
  emailVerified: Boolean
  # This is the object authData.
  authData: Object
}

# The Date scalar type
 is used in operations and types that involve dates.
scalar Date

# The DateWhereInput input type is used in operations that involve filtering objects by a field of type Date.
input DateWhereInput {
  # This is the equalTo operator to specify a constraint to select the objects
  # where the value of a field equals to a specified value.
  equalTo: Date
  # This is the notEqualTo operator to specify a constraint to select the objects
  # where the value of a field do not equal to a specified value.
  notEqualTo: Date
  # This is the lessThan operator to specify a constraint to select the objects
  # where the value of a field is less than a specified value.
  lessThan: Date
  # This is the lessThanOrEqualTo operator to specify a constraint to select the
  # objects where the value of a field is less than or equal to a specified value.
  lessThanOrEqualTo: Date
  # This is the greaterThan operator to specify a constraint to select the objects
  # where the value of a field is greater than a specified value.
  greaterThan: Date
  # This is the greaterThanOrEqualTo operator to specify a constraint to select
  # the objects where the value of a field is greater than or equal to a specified value.
  greaterThanOrEqualTo: Date
  # This is the in operator to specify a constraint to select the objects where
  # the value of a field equals any value in the specified array.
  in: [Date]
  # This is the notIn operator to specify a constraint to select the objects where
  # the value of a field do not equal any value in the specified array.
  notIn: [Date]
  # This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist).
  exists: Boolean
  # This is the inQueryKey operator to specify a constraint to select the objects
  # where a field equals to a key in the result of a different query.
  inQueryKey: SelectInput
  # This is the notInQueryKey operator to specify a constraint to select the
  # objects where a field do not equal to a key in the result of a different query.
  notInQueryKey: SelectInput
}

# The Element object type is used to return array items' value.
type Element {
  # Return the value of the element in the array
  value: Any!
}

# The File scalar type
 is used in operations and types that involve files.
scalar File

# The FileInfo object type is used to return the information about files.
type FileInfo {
  # This is the file name.
  name: String!
  # This is the url in which the file can be downloaded.
  url: String!
}

# The FileWhereInput input type is used in operations that involve filtering objects by a field of type File.
input FileWhereInput {
  # This is the equalTo operator to specify a constraint to select the objects
  # where the value of a field equals to a specified value.
  equalTo: File
  # This is the notEqualTo operator to specify a constraint to select the objects
  # where the value of a field do not equal to a specified value.
  notEqualTo: File
  # This is the lessThan operator to specify a constraint to select the objects
  # where the value of a field is less than a specified value.
  lessThan: File
  # This is the lessThanOrEqualTo operator to specify a constraint to select the
  # objects where the value of a field is less than or equal to a specified value.
  lessThanOrEqualTo: File
  # This is the greaterThan operator to specify a constraint to select the objects
  # where the value of a field is greater than a specified value.
  greaterThan: File
  # This is the greaterThanOrEqualTo operator to specify a constraint to select
  # the objects where the value of a field is greater than or equal to a specified value.
  greaterThanOrEqualTo: File
  # This is the in operator to specify a constraint to select the objects where
  # the value of a field equals any value in the specified array.
  in: [File]
  # This is the notIn operator to specify a constraint to select the objects where
  # the value of a field do not equal any value in the specified array.
  notIn: [File]
  # This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist).
  exists: Boolean
  # This is the inQueryKey operator to specify a constraint to select the objects
  # where a field equals to a key in the result of a different query.
  inQueryKey: SelectInput
  # This is the notInQueryKey operator to specify a constraint to select the
  # objects where a field do not equal to a key in the result of a different query.
  notInQueryKey: SelectInput
  # This is the matchesRegex operator to specify a constraint to select the
  # objects where the value of a field matches a specified regular expression.
  matchesRegex: String
  # This is the options operator to specify optional flags (such as "i" and "m")
  # to be added to a matchesRegex operation in the same set of constraints.
  options: String
}

# The FindResult object type is used in the find queries to return the data of the matched objects.
type FindResult {
  # This is the objects returned by the query
  results: [Object!]!
  # This is the total matched objecs count that is returned when the count flag is set.
  count: Int!
}

# The GeoIntersectsInput type is used to specify a geoIntersects operation on a constraint.
input GeoIntersectsInput {
  # This is the point to be specified.
  point: GeoPointInput
}

# The GeoPoint object type is used to return the information about geo point fields.
type GeoPoint {
  # This is the latitude.
  latitude: Float!
  # This is the longitude.
  longitude: Float!
}

# The GeoPointInput type is used in operations that involve inputting fields of type geo point.
input GeoPointInput {
  # This is the latitude.
  latitude: Float!
  # This is the longitude.
  longitude: Float!
}

# The GeoPointWhereInput input type is used in operations that involve filtering objects by a field of type GeoPoint.
input GeoPointWhereInput {
  # This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist).
  exists: Boolean
  # This is the nearSphere operator to specify a constraint to select the objects
  # where the values of a geo point field is near to another geo point.
  nearSphere: GeoPointInput
  # This is the maxDistance operator to specify a constraint to select the objects
  # where the values of a geo point field is at a max distance (in radians) from
  # the geo point specified in the $nearSphere operator.
  maxDistance: Float
  # This is the maxDistanceInRadians operator to specify a constraint to select
  # the objects where the values of a geo point field is at a max distance (in
  # radians) from the geo point specified in the $nearSphere operator.
  maxDistanceInRadians: Float
  # This is the maxDistanceInMiles operator to specify a constraint to select the
  # objects where the values of a geo point field is at a max distance (in miles)
  # from the geo point specified in the $nearSphere operator.
  maxDistanceInMiles: Float
  # This is the maxDistanceInKilometers operator to specify a constraint to select
  # the objects where the values of a geo point field is at a max distance (in
  # kilometers) from the geo point specified in the $nearSphere operator.
  maxDistanceInKilometers: Float
  # This is the within operator to specify a constraint to select the objects
  # where the values of a geo point field is within a specified box.
  within: WithinInput
  # This is the geoWithin operator to specify a constraint to select the objects
  # where the values of a geo point field is within a specified polygon or sphere.
  geoWithin: GeoWithinInput
}

# The GeoWithinInput type is used to specify a geoWithin operation on a constraint.
input GeoWithinInput {
  # This is the polygon to be specified.
  polygon: [GeoPointInput!]
  # This is the sphere to be specified.
  centerSphere: CenterSphereInput
}

# An entry from an object, i.e., a pair of key and value.
input KeyValueInput {
  # The key used to retrieve the value of this entry.
  key: String!
  # The value of the entry. Could be any type of scalar data
.
  value: Any!
}

# The LogInFieldsInput input type is used to login.
input LogInFieldsInput {
  # This is the username used to log the user in.
  username: String!
  # This is the password used to log the user in.
  password: String!
}

# Mutation is the top level type for mutations.
type Mutation {
  # The createRole mutation can be used to create a new object of the Role class.
  createRole(
    # These are the fields used to create the object.
    fields: CreateRoleFieldsInput
  ): Role!
  # The updateRole mutation can be used to update an object of the Role class.
  updateRole(
    # This is the object id.
    id: ID!
    # These are the fields used to update the object.
    fields: UpdateRoleFieldsInput
  ): Role!
  # The deleteRole mutation can be used to delete an object of the Role class.
  deleteRole(
    # This is the object id.
    id: ID!
  ): Role!
  # The createUser mutation can be used to create a new object of the User class.
  createUser(
    # These are the fields used to create the object.
    fields: CreateUserFieldsInput
  ): User!
  # The updateUser mutation can be used to update an object of the User class.
  updateUser(
    # This is the object id.
    id: ID!
    # These are the fields used to update the object.
    fields: UpdateUserFieldsInput
  ): User!
  # The deleteUser mutation can be used to delete an object of the User class.
  deleteUser(
    # This is the object id.
    id: ID!
  ): User!
  # The createBudgetCategory mutation can be used to create a new object of the BudgetCategory class.
  createBudgetCategory(
    # These are the fields used to create the object.
    fields: CreateBudgetCategoryFieldsInput
  ): BudgetCategory!
  # The updateBudgetCategory mutation can be used to update an object of the BudgetCategory class.
  updateBudgetCategory(
    # This is the object id.
    id: ID!
    # These are the fields used to update the object.
    fields: UpdateBudgetCategoryFieldsInput
  ): BudgetCategory!
  # The deleteBudgetCategory mutation can be used to delete an object of the BudgetCategory class.
  deleteBudgetCategory(
    # This is the object id.
    id: ID!
  ): BudgetCategory!
  # The createShoppingCategory mutation can be used to create a new object of the ShoppingCategory class.
  createShoppingCategory(
    # These are the fields used to create the object.
    fields: CreateShoppingCategoryFieldsInput
  ): ShoppingCategory!
  # The updateShoppingCategory mutation can be used to update an object of the ShoppingCategory class.
  updateShoppingCategory(
    # This is the object id.
    id: ID!
    # These are the fields used to update the object.
    fields: UpdateShoppingCategoryFieldsInput
  ): ShoppingCategory!
  # The deleteShoppingCategory mutation can be used to delete an object of the ShoppingCategory class.
  deleteShoppingCategory(
    # This is the object id.
    id: ID!
  ): ShoppingCategory!
  # The createShoppingItem mutation can be used to create a new object of the ShoppingItem class.
  createShoppingItem(
    # These are the fields used to create the object.
    fields: CreateShoppingItemFieldsInput
  ): ShoppingItem!
  # The updateShoppingItem mutation can be used to update an object of the ShoppingItem class.
  updateShoppingItem(
    # This is the object id.
    id: ID!
    # These are the fields used to update the object.
    fields: UpdateShoppingItemFieldsInput
  ): ShoppingItem!
  # The deleteShoppingItem mutation can be used to delete an object of the ShoppingItem class.
  deleteShoppingItem(
    # This is the object id.
    id: ID!
  ): ShoppingItem!
  # The createTransactionItem mutation can be used to create a new object of the TransactionItem class.
  createTransactionItem(
    # These are the fields used to create the object.
    fields: CreateTransactionItemFieldsInput
  ): TransactionItem!
  # The updateTransactionItem mutation can be used to update an object of the TransactionItem class.
  updateTransactionItem(
    # This is the object id.
    id: ID!
    # These are the fields used to update the object.
    fields: UpdateTransactionItemFieldsInput
  ): TransactionItem!
  # The deleteTransactionItem mutation can be used to delete an object of the TransactionItem class.
  deleteTransactionItem(
    # This is the object id.
    id: ID!
  ): TransactionItem!
  # The create mutation can be used to create and upload a new file.
  createFile(
    # This is the new file to be created and uploaded
    upload: Upload!
  ): FileInfo!
  # The signUp mutation can be used to sign the user up.
  signUp(fields: SignUpFieldsInput): Viewer!
  # The logIn mutation can be used to log the user in.
  logIn(
    # This is data needed to login
    fields: LogInFieldsInput
  ): Viewer!
  # The logOut mutation can be used to log the user out.
  logOut: Viewer!
  # The createClass mutation can be used to create the schema for a new object class.
  createClass(
    # This is the name of the object class.
    name: String!
    # These are the schema's fields of the object class.
    schemaFields: SchemaFieldsInput
  ): Class!
  # The updateClass mutation can be used to update the schema for an existing object class.
  updateClass(
    # This is the name of the object class.
    name: String!
    # These are the schema's fields of the object class.
    schemaFields: SchemaFieldsInput
  ): Class!
  # The deleteClass mutation can be used to delete an existing object class.
  deleteClass(
    # This is the name of the object class.
    name: String!
  ): Class!
}

# The NumberWhereInput input type is used in operations that involve filtering objects by a field of type Number.
input NumberWhereInput {
  # This is the equalTo operator to specify a constraint to select the objects
  # where the value of a field equals to a specified value.
  equalTo: Float
  # This is the notEqualTo operator to specify a constraint to select the objects
  # where the value of a field do not equal to a specified value.
  notEqualTo: Float
  # This is the lessThan operator to specify a constraint to select the objects
  # where the value of a field is less than a specified value.
  lessThan: Float
  # This is the lessThanOrEqualTo operator to specify a constraint to select the
  # objects where the value of a field is less than or equal to a specified value.
  lessThanOrEqualTo: Float
  # This is the greaterThan operator to specify a constraint to select the objects
  # where the value of a field is greater than a specified value.
  greaterThan: Float
  # This is the greaterThanOrEqualTo operator to specify a constraint to select
  # the objects where the value of a field is greater than or equal to a specified value.
  greaterThanOrEqualTo: Float
  # This is the in operator to specify a constraint to select the objects where
  # the value of a field equals any value in the specified array.
  in: [Float]
  # This is the notIn operator to specify a constraint to select the objects where
  # the value of a field do not equal any value in the specified array.
  notIn: [Float]
  # This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist).
  exists: Boolean
  # This is the inQueryKey operator to specify a constraint to select the objects
  # where a field equals to a key in the result of a different query.
  inQueryKey: SelectInput
  # This is the notInQueryKey operator to specify a constraint to select the
  # objects where a field do not equal to a key in the result of a different query.
  notInQueryKey: SelectInput
}

# The Object scalar type
 is used in operations and types that involve objects.
scalar Object

# The ObjectWhereInput input type is used in operations that involve filtering result by a field of type Object.
input ObjectWhereInput {
  # This is the equalTo operator to specify a constraint to select the objects
  # where the value of a field equals to a specified value.
  equalTo: KeyValueInput
  # This is the notEqualTo operator to specify a constraint to select the objects
  # where the value of a field do not equal to a specified value.
  notEqualTo: KeyValueInput
  # This is the in operator to specify a constraint to select the objects where
  # the value of a field equals any value in the specified array.
  in: [KeyValueInput]
  # This is the notIn operator to specify a constraint to select the objects where
  # the value of a field do not equal any value in the specified array.
  notIn: [KeyValueInput]
  # This is the lessThan operator to specify a constraint to select the objects
  # where the value of a field is less than a specified value.
  lessThan: KeyValueInput
  # This is the lessThanOrEqualTo operator to specify a constraint to select the
  # objects where the value of a field is less than or equal to a specified value.
  lessThanOrEqualTo: KeyValueInput
  # This is the greaterThan operator to specify a constraint to select the objects
  # where the value of a field is greater than a specified value.
  greaterThan: KeyValueInput
  # This is the greaterThanOrEqualTo operator to specify a constraint to select
  # the objects where the value of a field is greater than or equal to a specified value.
  greaterThanOrEqualTo: KeyValueInput
  # This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist).
  exists: Boolean
  # This is the inQueryKey operator to specify a constraint to select the objects
  # where a field equals to a key in the result of a different query.
  inQueryKey: SelectInput
  # This is the notInQueryKey operator to specify a constraint to select the
  # objects where a field do not equal to a key in the result of a different query.
  notInQueryKey: SelectInput
}

# The ParseObject interface type is used as a base type for the auto generated object types.
interface ParseObject {
  # This is the object id.
  id: ID!
  # This is the date in which the object was created.
  createdAt: Date!
  # This is the date in which the object was las updated.
  updatedAt: Date!
  # This is the access control list of the object.
  ACL: Object
}

# The PointerFieldInput is used to specify a field of type pointer for an object class schema.
input PointerFieldInput {
  # This is the field name.
  name: String!
  # This is the name of the target class for the field.
  targetClassName: String!
}

# The PolygonWhereInput input type is used in operations that involve filtering objects by a field of type Polygon.
input PolygonWhereInput {
  # This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist).
  exists: Boolean
  # This is the geoIntersects operator to specify a constraint to select the
  # objects where the values of a polygon field intersect a specified point.
  geoIntersects: GeoIntersectsInput
}

# Query is the top level type for queries.
type Query {
  # The role query can be used to get an object of the Role class by its id.
  role(
    # This is the object id.
    id: ID!
    # The read options for the query to be executed.
    options: ReadOptionsInput
  ): Role!
  # The roles query can be used to find objects of the Role class.
  roles(
    # These are the conditions that the objects need to match in order to be found.
    where: RoleWhereInput
    # The fields to be used when sorting the data fetched.
    order: [RoleOrder!]
    # This is the number of objects that must be skipped to return.
    skip: Int
    # This is the limit number of objects that must be returned.
    limit: Int
    # The read options for the query to be executed.
    options: ReadOptionsInput
  ): RoleFindResult!
  # The user query can be used to get an object of the User class by its id.
  user(
    # This is the object id.
    id: ID!
    # The read options for the query to be executed.
    options: ReadOptionsInput
  ): User!
  # The users query can be used to find objects of the User class.
  users(
    # These are the conditions that the objects need to match in order to be found.
    where: UserWhereInput
    # The fields to be used when sorting the data fetched.
    order: [UserOrder!]
    # This is the number of objects that must be skipped to return.
    skip: Int
    # This is the limit number of objects that must be returned.
    limit: Int
    # The read options for the query to be executed.
    options: ReadOptionsInput
  ): UserFindResult!
  # The budgetCategory query can be used to get an object of the BudgetCategory class by its id.
  budgetCategory(
    # This is the object id.
    id: ID!
    # The read options for the query to be executed.
    options: ReadOptionsInput
  ): BudgetCategory!
  # The budgetCategories query can be used to find objects of the BudgetCategory class.
  budgetCategories(
    # These are the conditions that the objects need to match in order to be found.
    where: BudgetCategoryWhereInput
    # The fields to be used when sorting the data fetched.
    order: [BudgetCategoryOrder!]
    # This is the number of objects that must be skipped to return.
    skip: Int
    # This is the limit number of objects that must be returned.
    limit: Int
    # The read options for the query to be executed.
    options: ReadOptionsInput
  ): BudgetCategoryFindResult!
  # The shoppingCategory query can be used to get an object of the ShoppingCategory class by its id.
  shoppingCategory(
    # This is the object id.
    id: ID!
    # The read options for the query to be executed.
    options: ReadOptionsInput
  ): ShoppingCategory!
  # The shoppingCategories query can be used to find objects of the ShoppingCategory class.
  shoppingCategories(
    # These are the conditions that the objects need to match in order to be found.
    where: ShoppingCategoryWhereInput
    # The fields to be used when sorting the data fetched.
    order: [ShoppingCategoryOrder!]
    # This is the number of objects that must be skipped to return.
    skip: Int
    # This is the limit number of objects that must be returned.
    limit: Int
    # The read options for the query to be executed.
    options: ReadOptionsInput
  ): ShoppingCategoryFindResult!
  # The shoppingItem query can be used to get an object of the ShoppingItem class by its id.
  shoppingItem(
    # This is the object id.
    id: ID!
    # The read options for the query to be executed.
    options: ReadOptionsInput
  ): ShoppingItem!
  # The shoppingItems query can be used to find objects of the ShoppingItem class.
  shoppingItems(
    # These are the conditions that the objects need to match in order to be found.
    where: ShoppingItemWhereInput
    # The fields to be used when sorting the data fetched.
    order: [ShoppingItemOrder!]
    # This is the number of objects that must be skipped to return.
    skip: Int
    # This is the limit number of objects that must be returned.
    limit: Int
    # The read options for the query to be executed.
    options: ReadOptionsInput
  ): ShoppingItemFindResult!
  # The transactionItem query can be used to get an object of the TransactionItem class by its id.
  transactionItem(
    # This is the object id.
    id: ID!
    # The read options for the query to be executed.
    options: ReadOptionsInput
  ): TransactionItem!
  # The transactionItems query can be used to find objects of the TransactionItem class.
  transactionItems(
    # These are the conditions that the objects need to match in order to be found.
    where: TransactionItemWhereInput
    # The fields to be used when sorting the data fetched.
    order: [TransactionItemOrder!]
    # This is the number of objects that must be skipped to return.
    skip: Int
    # This is the limit number of objects that must be returned.
    limit: Int
    # The read options for the query to be executed.
    options: ReadOptionsInput
  ): TransactionItemFindResult!
  # The health query can be used to check if the server is up and running.
  health: Boolean!
  # The viewer query can be used to return the current user data.
  viewer: Viewer!
  # The class query can be used to retrieve an existing object class.
  class(
    # This is the name of the object class.
    name: String!
  ): Class!
  # The classes query can be used to retrieve the existing object classes.
  classes: [Class!]!
}

# The ReadOptionsInputt type is used in queries in order to set the read preferences.
input ReadOptionsInput {
  # The read preference for the main query to be executed.
  readPreference: ReadPreference
  # The read preference for the queries to be executed to include fields.
  includeReadPreference: ReadPreference
  # The read preference for the subqueries that may be required.
  subqueryReadPreference: ReadPreference
}

# The ReadPreference enum type is used in queries in order to select in which database replica the operation must run.
enum ReadPreference {
  PRIMARY
  PRIMARY_PREFERRED
  SECONDARY
  SECONDARY_PREFERRED
  NEAREST
}

# The RelationFieldInput is used to specify a field of type relation for an object class schema.
input RelationFieldInput {
  # This is the field name.
  name: String!
  # This is the name of the target class for the field.
  targetClassName: String!
}

# The Role object type is used in operations that involve outputting objects of Role class.
type Role implements ParseObject {
  # This is the object id.
  id: ID!
  # This is the date in which the object was created.
  createdAt: Date!
  # This is the date in which the object was las updated.
  updatedAt: Date!
  # This is the access control list of the object.
  ACL: Object
  # This is the object name.
  name: String
  # This is the object users.
  users(
    # These are the conditions that the objects need to match in order to be found.
    where: UserWhereInput
    # The fields to be used when sorting the data fetched.
    order: [UserOrder!]
    # This is the number of objects that must be skipped to return.
    skip: Int
    # This is the limit number of objects that must be returned.
    limit: Int
    # The read options for the query to be executed.
    options: ReadOptionsInput
  ): UserFindResult!
  # This is the object roles.
  roles(
    # These are the conditions that the objects need to match in order to be found.
    where: RoleWhereInput
    # The fields to be used when sorting the data fetched.
    order: [RoleOrder!]
    # This is the number of objects that must be skipped to return.
    skip: Int
    # This is the limit number of objects that must be returned.
    limit: Int
    # The read options for the query to be executed.
    options: ReadOptionsInput
  ): RoleFindResult!
}

# The RoleFindResult object type is used in the Role find query to return the data of the matched objects.
type RoleFindResult {
  # This is the objects returned by the query
  results: [Role!]!
  # This is the total matched objecs count that is returned when the count flag is set.
  count: Int!
}

# The RoleOrder input type is used when sorting objects of the Role class.
enum RoleOrder {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  ACL_ASC
  ACL_DESC
  name_ASC
  name_DESC
  users_ASC
  users_DESC
  roles_ASC
  roles_DESC
  id_ASC
  id_DESC
}

# Allow to link OR add and link an object of the Role class.
input RolePointerInput {
  # Link an existing object from Role class.
  link: ID
  # Create and link an object from Role class.
  createAndLink: CreateRoleFieldsInput
}

# The RolePointerWhereInput input type is used in operations that involve filtering objects by a pointer field to Role class.
input RolePointerWhereInput {
  # This is the equalTo operator to specify a constraint to select the objects
  # where the value of a field equals to a specified value.
  equalTo: ID
  # This is the notEqualTo operator to specify a constraint to select the objects
  # where the value of a field do not equal to a specified value.
  notEqualTo: ID
  # This is the in operator to specify a constraint to select the objects where
  # the value of a field equals any value in the specified array.
  in: [ID!]
  # This is the notIn operator to specify a constraint to select the objects where
  # the value of a field do not equal any value in the specified array.
  notIn: [ID!]
  # This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist).
  exists: Boolean
  # This is the inQueryKey operator to specify a constraint to select the objects
  # where a field equals to a key in the result of a different query.
  inQueryKey: SelectInput
  # This is the notInQueryKey operator to specify a constraint to select the
  # objects where a field do not equal to a key in the result of a different query.
  notInQueryKey: SelectInput
  # This is the inQuery operator to specify a constraint to select the objects
  # where a field equals to any of the ids in the result of a different query.
  inQuery: SubqueryInput
  # This is the notInQuery operator to specify a constraint to select the objects
  # where a field do not equal to any of the ids in the result of a different query.
  notInQuery: SubqueryInput
}

# Allow to add, remove, createAndAdd objects of the Role class into a relation field.
input RoleRelationInput {
  # Add an existing object from the Role class into the relation.
  add: [ID!]
  # Remove an existing object from the Role class out of the relation.
  remove: [ID!]
  # Create and add an object of the Role class into the relation.
  createAndAdd: [CreateRoleFieldsInput!]
}

# The RoleWhereInput input type is used in operations that involve filtering objects of Role class.
input RoleWhereInput {
  # This is the object createdAt.
  createdAt: DateWhereInput
  # This is the object updatedAt.
  updatedAt: DateWhereInput
  # This is the object ACL.
  ACL: ObjectWhereInput
  # This is the object name.
  name: StringWhereInput
  # This is the object id.
  id: StringWhereInput
  # This is the OR operator to compound constraints.
  OR: [RoleWhereInput!]
  # This is the AND operator to compound constraints.
  AND: [RoleWhereInput!]
  # This is the NOR operator to compound constraints.
  NOR: [RoleWhereInput!]
}

# The SchemaACLField is used to return information of an ACL field.
type SchemaACLField implements SchemaField {
  # This is the field name.
  name: String!
}

# The SchemaArrayField is used to return information of an Array field.
type SchemaArrayField implements SchemaField {
  # This is the field name.
  name: String!
}

# The SchemaArrayFieldInput is used to specify a field of type array for an object class schema.
input SchemaArrayFieldInput {
  # This is the field name.
  name: String!
}

# The SchemaBooleanField is used to return information of a Boolean field.
type SchemaBooleanField implements SchemaField {
  # This is the field name.
  name: String!
}

# The SchemaBooleanFieldInput is used to specify a field of type boolean for an object class schema.
input SchemaBooleanFieldInput {
  # This is the field name.
  name: String!
}

# The SchemaBytesField is used to return information of a Bytes field.
type SchemaBytesField implements SchemaField {
  # This is the field name.
  name: String!
}

# The SchemaBytesFieldInput is used to specify a field of type bytes for an object class schema.
input SchemaBytesFieldInput {
  # This is the field name.
  name: String!
}

# The SchemaDateField is used to return information of a Date field.
type SchemaDateField implements SchemaField {
  # This is the field name.
  name: String!
}

# The SchemaDateFieldInput is used to specify a field of type date for an object class schema.
input SchemaDateFieldInput {
  # This is the field name.
  name: String!
}

# The SchemaField interface type is used as a base type for the different supported fields of an object class schema.
interface SchemaField {
  # This is the field name.
  name: String!
}

# The SchemaFieldInput is used to specify a field of an object class schema.
input SchemaFieldInput {
  # This is the field name.
  name: String!
}

# The CreateClassSchemaInput type is used to specify the schema for a new object class to be created.
input SchemaFieldsInput {
  # These are the String fields to be added to the class schema.
  addStrings: [SchemaStringFieldInput!]
  # These are the Number fields to be added to the class schema.
  addNumbers: [SchemaNumberFieldInput!]
  # These are the Boolean fields to be added to the class schema.
  addBooleans: [SchemaBooleanFieldInput!]
  # These are the Array fields to be added to the class schema.
  addArrays: [SchemaArrayFieldInput!]
  # These are the Object fields to be added to the class schema.
  addObjects: [SchemaObjectFieldInput!]
  # These are the Date fields to be added to the class schema.
  addDates: [SchemaDateFieldInput!]
  # These are the File fields to be added to the class schema.
  addFiles: [SchemaFileFieldInput!]
  # This is the Geo Point field to be added to the class schema. Currently it is supported only one GeoPoint field per Class.
  addGeoPoint: SchemaGeoPointFieldInput
  # These are the Polygon fields to be added to the class schema.
  addPolygons: [SchemaPolygonFieldInput!]
  # These are the Bytes fields to be added to the class schema.
  addBytes: [SchemaBytesFieldInput!]
  # These are the Pointer fields to be added to the class schema.
  addPointers: [PointerFieldInput!]
  # These are the Relation fields to be added to the class schema.
  addRelations: [RelationFieldInput!]
  # These are the fields to be removed from the class schema.
  remove: [SchemaFieldInput!]
}

# The SchemaFileField is used to return information of a File field.
type SchemaFileField implements SchemaField {
  # This is the field name.
  name: String!
}

# The SchemaFileFieldInput is used to specify a field of type file for an object class schema.
input SchemaFileFieldInput {
  # This is the field name.
  name: String!
}

# The SchemaGeoPointField is used to return information of a Geo Point field.
type SchemaGeoPointField implements SchemaField {
  # This is the field name.
  name: String!
}

# The SchemaGeoPointFieldInput is used to specify a field of type geo point for an object class schema.
input SchemaGeoPointFieldInput {
  # This is the field name.
  name: String!
}

# The SchemaNumberField is used to return information of a Number field.
type SchemaNumberField implements SchemaField {
  # This is the field name.
  name: String!
}

# The SchemaNumberFieldInput is used to specify a field of type number for an object class schema.
input SchemaNumberFieldInput {
  # This is the field name.
  name: String!
}

# The SchemaObjectField is used to return information of an Object field.
type SchemaObjectField implements SchemaField {
  # This is the field name.
  name: String!
}

# The SchemaObjectFieldInput is used to specify a field of type object for an object class schema.
input SchemaObjectFieldInput {
  # This is the field name.
  name: String!
}

# The SchemaPointerField is used to return information of a Pointer field.
type SchemaPointerField implements SchemaField {
  # This is the field name.
  name: String!
  # This is the name of the target class for the field.
  targetClassName: String!
}

# The SchemaPolygonField is used to return information of a Polygon field.
type SchemaPolygonField implements SchemaField {
  # This is the field name.
  name: String!
}

# The SchemaPolygonFieldInput is used to specify a field of type polygon for an object class schema.
input SchemaPolygonFieldInput {
  # This is the field name.
  name: String!
}

# The SchemaRelationField is used to return information of a Relation field.
type SchemaRelationField implements SchemaField {
  # This is the field name.
  name: String!
  # This is the name of the target class for the field.
  targetClassName: String!
}

# The SchemaStringField is used to return information of a String field.
type SchemaStringField implements SchemaField {
  # This is the field name.
  name: String!
}

# The SchemaStringFieldInput is used to specify a field of type string for an object class schema.
input SchemaStringFieldInput {
  # This is the field name.
  name: String!
}

# The SearchInput type is used to specifiy a search operation on a full text search.
input SearchInput {
  # This is the term to be searched.
  term: String!
  # This is the language to tetermine the list of stop words and the rules for tokenizer.
  language: String
  # This is the flag to enable or disable case sensitive search.
  caseSensitive: Boolean
  # This is the flag to enable or disable diacritic sensitive search.
  diacriticSensitive: Boolean
}

# The SelectInput type is used to specify an inQueryKey or a notInQueryKey operation on a constraint.
input SelectInput {
  # This is the subquery to be executed.
  query: SubqueryInput!
  # This is the key in the result of the subquery that must match (not match) the field.
  key: String!
}

# The ShoppingCategory object type is used in operations that involve outputting objects of ShoppingCategory class.
type ShoppingCategory implements ParseObject {
  # This is the object id.
  id: ID!
  # This is the date in which the object was created.
  createdAt: Date!
  # This is the date in which the object was las updated.
  updatedAt: Date!
  # This is the access control list of the object.
  ACL: Object
  # This is the object name.
  name: String
}

# The ShoppingCategoryFindResult object type is used in the ShoppingCategory find
# query to return the data of the matched objects.
type ShoppingCategoryFindResult {
  # This is the objects returned by the query
  results: [ShoppingCategory!]!
  # This is the total matched objecs count that is returned when the count flag is set.
  count: Int!
}

# The ShoppingCategoryOrder input type is used when sorting objects of the ShoppingCategory class.
enum ShoppingCategoryOrder {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  ACL_ASC
  ACL_DESC
  name_ASC
  name_DESC
  id_ASC
  id_DESC
}

# Allow to link OR add and link an object of the ShoppingCategory class.
input ShoppingCategoryPointerInput {
  # Link an existing object from ShoppingCategory class.
  link: ID
  # Create and link an object from ShoppingCategory class.
  createAndLink: CreateShoppingCategoryFieldsInput
}

# The ShoppingCategoryPointerWhereInput input type is used in operations that
# involve filtering objects by a pointer field to ShoppingCategory class.
input ShoppingCategoryPointerWhereInput {
  # This is the equalTo operator to specify a constraint to select the objects
  # where the value of a field equals to a specified value.
  equalTo: ID
  # This is the notEqualTo operator to specify a constraint to select the objects
  # where the value of a field do not equal to a specified value.
  notEqualTo: ID
  # This is the in operator to specify a constraint to select the objects where
  # the value of a field equals any value in the specified array.
  in: [ID!]
  # This is the notIn operator to specify a constraint to select the objects where
  # the value of a field do not equal any value in the specified array.
  notIn: [ID!]
  # This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist).
  exists: Boolean
  # This is the inQueryKey operator to specify a constraint to select the objects
  # where a field equals to a key in the result of a different query.
  inQueryKey: SelectInput
  # This is the notInQueryKey operator to specify a constraint to select the
  # objects where a field do not equal to a key in the result of a different query.
  notInQueryKey: SelectInput
  # This is the inQuery operator to specify a constraint to select the objects
  # where a field equals to any of the ids in the result of a different query.
  inQuery: SubqueryInput
  # This is the notInQuery operator to specify a constraint to select the objects
  # where a field do not equal to any of the ids in the result of a different query.
  notInQuery: SubqueryInput
}

# Allow to add, remove, createAndAdd objects of the ShoppingCategory class into a relation field.
input ShoppingCategoryRelationInput {
  # Add an existing object from the ShoppingCategory class into the relation.
  add: [ID!]
  # Remove an existing object from the ShoppingCategory class out of the relation.
  remove: [ID!]
  # Create and add an object of the ShoppingCategory class into the relation.
  createAndAdd: [CreateShoppingCategoryFieldsInput!]
}

# The ShoppingCategoryWhereInput input type is used in operations that involve filtering objects of ShoppingCategory class.
input ShoppingCategoryWhereInput {
  # This is the object createdAt.
  createdAt: DateWhereInput
  # This is the object updatedAt.
  updatedAt: DateWhereInput
  # This is the object ACL.
  ACL: ObjectWhereInput
  # This is the object name.
  name: StringWhereInput
  # This is the object id.
  id: StringWhereInput
  # This is the OR operator to compound constraints.
  OR: [ShoppingCategoryWhereInput!]
  # This is the AND operator to compound constraints.
  AND: [ShoppingCategoryWhereInput!]
  # This is the NOR operator to compound constraints.
  NOR: [ShoppingCategoryWhereInput!]
}

# The ShoppingItem object type is used in operations that involve outputting objects of ShoppingItem class.
type ShoppingItem implements ParseObject {
  # This is the object id.
  id: ID!
  # This is the date in which the object was created.
  createdAt: Date!
  # This is the date in which the object was las updated.
  updatedAt: Date!
  # This is the access control list of the object.
  ACL: Object
  # This is the object name.
  name: String
  # This is the object localizedName.
  localizedName: String
  # This is the object price.
  price: Float
  # This is the object isNeeded.
  isNeeded: Boolean
  # This is the object shoppingCategory.
  shoppingCategory: ShoppingCategory
}

# The ShoppingItemFindResult object type is used in the ShoppingItem find query to return the data of the matched objects.
type ShoppingItemFindResult {
  # This is the objects returned by the query
  results: [ShoppingItem!]!
  # This is the total matched objecs count that is returned when the count flag is set.
  count: Int!
}

# The ShoppingItemOrder input type is used when sorting objects of the ShoppingItem class.
enum ShoppingItemOrder {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  ACL_ASC
  ACL_DESC
  name_ASC
  name_DESC
  localizedName_ASC
  localizedName_DESC
  price_ASC
  price_DESC
  isNeeded_ASC
  isNeeded_DESC
  shoppingCategory_ASC
  shoppingCategory_DESC
  id_ASC
  id_DESC
}

# Allow to link OR add and link an object of the ShoppingItem class.
input ShoppingItemPointerInput {
  # Link an existing object from ShoppingItem class.
  link: ID
  # Create and link an object from ShoppingItem class.
  createAndLink: CreateShoppingItemFieldsInput
}

# The ShoppingItemPointerWhereInput input type is used in operations that involve
# filtering objects by a pointer field to ShoppingItem class.
input ShoppingItemPointerWhereInput {
  # This is the equalTo operator to specify a constraint to select the objects
  # where the value of a field equals to a specified value.
  equalTo: ID
  # This is the notEqualTo operator to specify a constraint to select the objects
  # where the value of a field do not equal to a specified value.
  notEqualTo: ID
  # This is the in operator to specify a constraint to select the objects where
  # the value of a field equals any value in the specified array.
  in: [ID!]
  # This is the notIn operator to specify a constraint to select the objects where
  # the value of a field do not equal any value in the specified array.
  notIn: [ID!]
  # This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist).
  exists: Boolean
  # This is the inQueryKey operator to specify a constraint to select the objects
  # where a field equals to a key in the result of a different query.
  inQueryKey: SelectInput
  # This is the notInQueryKey operator to specify a constraint to select the
  # objects where a field do not equal to a key in the result of a different query.
  notInQueryKey: SelectInput
  # This is the inQuery operator to specify a constraint to select the objects
  # where a field equals to any of the ids in the result of a different query.
  inQuery: SubqueryInput
  # This is the notInQuery operator to specify a constraint to select the objects
  # where a field do not equal to any of the ids in the result of a different query.
  notInQuery: SubqueryInput
}

# Allow to add, remove, createAndAdd objects of the ShoppingItem class into a relation field.
input ShoppingItemRelationInput {
  # Add an existing object from the ShoppingItem class into the relation.
  add: [ID!]
  # Remove an existing object from the ShoppingItem class out of the relation.
  remove: [ID!]
  # Create and add an object of the ShoppingItem class into the relation.
  createAndAdd: [CreateShoppingItemFieldsInput!]
}

# The ShoppingItemWhereInput input type is used in operations that involve filtering objects of ShoppingItem class.
input ShoppingItemWhereInput {
  # This is the object createdAt.
  createdAt: DateWhereInput
  # This is the object updatedAt.
  updatedAt: DateWhereInput
  # This is the object ACL.
  ACL: ObjectWhereInput
  # This is the object name.
  name: StringWhereInput
  # This is the object localizedName.
  localizedName: StringWhereInput
  # This is the object price.
  price: NumberWhereInput
  # This is the object isNeeded.
  isNeeded: BooleanWhereInput
  # This is the object shoppingCategory.
  shoppingCategory: ShoppingCategoryPointerWhereInput
  # This is the object id.
  id: StringWhereInput
  # This is the OR operator to compound constraints.
  OR: [ShoppingItemWhereInput!]
  # This is the AND operator to compound constraints.
  AND: [ShoppingItemWhereInput!]
  # This is the NOR operator to compound constraints.
  NOR: [ShoppingItemWhereInput!]
}

# The SignUpFieldsInput input type is used in operations that involve inputting objects of User class when signing up.
input SignUpFieldsInput {
  # This is the object username.
  username: String!
  # This is the object password.
  password: String!
  # This is the object email.
  email: String
  # This is the object emailVerified.
  emailVerified: Boolean
  # This is the object authData.
  authData: Object
}

# The StringWhereInput input type is used in operations that involve filtering objects by a field of type String.
input StringWhereInput {
  # This is the equalTo operator to specify a constraint to select the objects
  # where the value of a field equals to a specified value.
  equalTo: String
  # This is the notEqualTo operator to specify a constraint to select the objects
  # where the value of a field do not equal to a specified value.
  notEqualTo: String
  # This is the lessThan operator to specify a constraint to select the objects
  # where the value of a field is less than a specified value.
  lessThan: String
  # This is the lessThanOrEqualTo operator to specify a constraint to select the
  # objects where the value of a field is less than or equal to a specified value.
  lessThanOrEqualTo: String
  # This is the greaterThan operator to specify a constraint to select the objects
  # where the value of a field is greater than a specified value.
  greaterThan: String
  # This is the greaterThanOrEqualTo operator to specify a constraint to select
  # the objects where the value of a field is greater than or equal to a specified value.
  greaterThanOrEqualTo: String
  # This is the in operator to specify a constraint to select the objects where
  # the value of a field equals any value in the specified array.
  in: [String]
  # This is the notIn operator to specify a constraint to select the objects where
  # the value of a field do not equal any value in the specified array.
  notIn: [String]
  # This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist).
  exists: Boolean
  # This is the inQueryKey operator to specify a constraint to select the objects
  # where a field equals to a key in the result of a different query.
  inQueryKey: SelectInput
  # This is the notInQueryKey operator to specify a constraint to select the
  # objects where a field do not equal to a key in the result of a different query.
  notInQueryKey: SelectInput
  # This is the matchesRegex operator to specify a constraint to select the
  # objects where the value of a field matches a specified regular expression.
  matchesRegex: String
  # This is the options operator to specify optional flags (such as "i" and "m")
  # to be added to a matchesRegex operation in the same set of constraints.
  options: String
  # This is the $text operator to specify a full text search constraint.
  text: TextInput
}

# The SubqueryInput type is used to specify a sub query to another class.
input SubqueryInput {
  # This is the class name of the object.
  className: String!
  # These are the conditions that the objects need to match in order to be found
  where: Object!
}

# The TextInput type is used to specify a text operation on a constraint.
input TextInput {
  # This is the search to be executed.
  search: SearchInput!
}

# The TransactionItem object type is used in operations that involve outputting objects of TransactionItem class.
type TransactionItem implements ParseObject {
  # This is the object id.
  id: ID!
  # This is the date in which the object was created.
  createdAt: Date!
  # This is the date in which the object was las updated.
  updatedAt: Date!
  # This is the access control list of the object.
  ACL: Object
  # This is the object name.
  name: String
  # This is the object value.
  value: Float
  # This is the object year.
  year: Float
  # This is the object month.
  month: Float
  # This is the object budgetCategory.
  budgetCategory: BudgetCategory
  # This is the object day.
  day: Float
  # This is the object location.
  location: String
}

# The TransactionItemFindResult object type is used in the TransactionItem find
# query to return the data of the matched objects.
type TransactionItemFindResult {
  # This is the objects returned by the query
  results: [TransactionItem!]!
  # This is the total matched objecs count that is returned when the count flag is set.
  count: Int!
}

# The TransactionItemOrder input type is used when sorting objects of the TransactionItem class.
enum TransactionItemOrder {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  ACL_ASC
  ACL_DESC
  name_ASC
  name_DESC
  value_ASC
  value_DESC
  year_ASC
  year_DESC
  month_ASC
  month_DESC
  budgetCategory_ASC
  budgetCategory_DESC
  day_ASC
  day_DESC
  location_ASC
  location_DESC
  id_ASC
  id_DESC
}

# Allow to link OR add and link an object of the TransactionItem class.
input TransactionItemPointerInput {
  # Link an existing object from TransactionItem class.
  link: ID
  # Create and link an object from TransactionItem class.
  createAndLink: CreateTransactionItemFieldsInput
}

# The TransactionItemPointerWhereInput input type is used in operations that
# involve filtering objects by a pointer field to TransactionItem class.
input TransactionItemPointerWhereInput {
  # This is the equalTo operator to specify a constraint to select the objects
  # where the value of a field equals to a specified value.
  equalTo: ID
  # This is the notEqualTo operator to specify a constraint to select the objects
  # where the value of a field do not equal to a specified value.
  notEqualTo: ID
  # This is the in operator to specify a constraint to select the objects where
  # the value of a field equals any value in the specified array.
  in: [ID!]
  # This is the notIn operator to specify a constraint to select the objects where
  # the value of a field do not equal any value in the specified array.
  notIn: [ID!]
  # This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist).
  exists: Boolean
  # This is the inQueryKey operator to specify a constraint to select the objects
  # where a field equals to a key in the result of a different query.
  inQueryKey: SelectInput
  # This is the notInQueryKey operator to specify a constraint to select the
  # objects where a field do not equal to a key in the result of a different query.
  notInQueryKey: SelectInput
  # This is the inQuery operator to specify a constraint to select the objects
  # where a field equals to any of the ids in the result of a different query.
  inQuery: SubqueryInput
  # This is the notInQuery operator to specify a constraint to select the objects
  # where a field do not equal to any of the ids in the result of a different query.
  notInQuery: SubqueryInput
}

# Allow to add, remove, createAndAdd objects of the TransactionItem class into a relation field.
input TransactionItemRelationInput {
  # Add an existing object from the TransactionItem class into the relation.
  add: [ID!]
  # Remove an existing object from the TransactionItem class out of the relation.
  remove: [ID!]
  # Create and add an object of the TransactionItem class into the relation.
  createAndAdd: [CreateTransactionItemFieldsInput!]
}

# The TransactionItemWhereInput input type is used in operations that involve filtering objects of TransactionItem class.
input TransactionItemWhereInput {
  # This is the object createdAt.
  createdAt: DateWhereInput
  # This is the object updatedAt.
  updatedAt: DateWhereInput
  # This is the object ACL.
  ACL: ObjectWhereInput
  # This is the object name.
  name: StringWhereInput
  # This is the object value.
  value: NumberWhereInput
  # This is the object year.
  year: NumberWhereInput
  # This is the object month.
  month: NumberWhereInput
  # This is the object budgetCategory.
  budgetCategory: BudgetCategoryPointerWhereInput
  # This is the object day.
  day: NumberWhereInput
  # This is the object location.
  location: StringWhereInput
  # This is the object id.
  id: StringWhereInput
  # This is the OR operator to compound constraints.
  OR: [TransactionItemWhereInput!]
  # This is the AND operator to compound constraints.
  AND: [TransactionItemWhereInput!]
  # This is the NOR operator to compound constraints.
  NOR: [TransactionItemWhereInput!]
}

# The UpdateBudgetCategoryFieldsInput input type is used in operations that
# involve creation of objects in the BudgetCategory class.
input UpdateBudgetCategoryFieldsInput {
  # This is the access control list of the object.
  ACL: Object
  # This is the object name.
  name: String
  # This is the object budget.
  budget: Float
}

# The UpdateRoleFieldsInput input type is used in operations that involve creation of objects in the Role class.
input UpdateRoleFieldsInput {
  # This is the access control list of the object.
  ACL: Object
  # This is the object name.
  name: String
  # This is the object users.
  users: UserRelationInput
  # This is the object roles.
  roles: RoleRelationInput
}

# The UpdateShoppingCategoryFieldsInput input type is used in operations that
# involve creation of objects in the ShoppingCategory class.
input UpdateShoppingCategoryFieldsInput {
  # This is the access control list of the object.
  ACL: Object
  # This is the object name.
  name: String
}

# The UpdateShoppingItemFieldsInput input type is used in operations that involve
# creation of objects in the ShoppingItem class.
input UpdateShoppingItemFieldsInput {
  # This is the access control list of the object.
  ACL: Object
  # This is the object name.
  name: String
  # This is the object localizedName.
  localizedName: String
  # This is the object price.
  price: Float
  # This is the object isNeeded.
  isNeeded: Boolean
  # This is the object shoppingCategory.
  shoppingCategory: ShoppingCategoryPointerInput
}

# The UpdateTransactionItemFieldsInput input type is used in operations that
# involve creation of objects in the TransactionItem class.
input UpdateTransactionItemFieldsInput {
  # This is the access control list of the object.
  ACL: Object
  # This is the object name.
  name: String
  # This is the object value.
  value: Float
  # This is the object year.
  year: Float
  # This is the object month.
  month: Float
  # This is the object budgetCategory.
  budgetCategory: BudgetCategoryPointerInput
  # This is the object day.
  day: Float
  # This is the object location.
  location: String
}

# The UpdateUserFieldsInput input type is used in operations that involve creation of objects in the User class.
input UpdateUserFieldsInput {
  # This is the access control list of the object.
  ACL: Object
  # This is the object username.
  username: String
  # This is the object password.
  password: String
  # This is the object email.
  email: String
  # This is the object emailVerified.
  emailVerified: Boolean
  # This is the object authData.
  authData: Object
}

# The `Upload` scalar type
 represents a file upload.
scalar Upload

# The User object type is used in operations that involve outputting objects of User class.
type User implements ParseObject {
  # This is the object id.
  id: ID!
  # This is the date in which the object was created.
  createdAt: Date!
  # This is the date in which the object was las updated.
  updatedAt: Date!
  # This is the access control list of the object.
  ACL: Object
  # This is the object username.
  username: String
  # This is the object email.
  email: String
  # This is the object emailVerified.
  emailVerified: Boolean
  # This is the object authData.
  authData: Object
}

# The UserFindResult object type is used in the User find query to return the data of the matched objects.
type UserFindResult {
  # This is the objects returned by the query
  results: [User!]!
  # This is the total matched objecs count that is returned when the count flag is set.
  count: Int!
}

# The UserOrder input type is used when sorting objects of the User class.
enum UserOrder {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  ACL_ASC
  ACL_DESC
  username_ASC
  username_DESC
  password_ASC
  password_DESC
  email_ASC
  email_DESC
  emailVerified_ASC
  emailVerified_DESC
  authData_ASC
  authData_DESC
  id_ASC
  id_DESC
}

# Allow to link OR add and link an object of the User class.
input UserPointerInput {
  # Link an existing object from User class.
  link: ID
  # Create and link an object from User class.
  createAndLink: CreateUserFieldsInput
}

# The UserPointerWhereInput input type is used in operations that involve filtering objects by a pointer field to User class.
input UserPointerWhereInput {
  # This is the equalTo operator to specify a constraint to select the objects
  # where the value of a field equals to a specified value.
  equalTo: ID
  # This is the notEqualTo operator to specify a constraint to select the objects
  # where the value of a field do not equal to a specified value.
  notEqualTo: ID
  # This is the in operator to specify a constraint to select the objects where
  # the value of a field equals any value in the specified array.
  in: [ID!]
  # This is the notIn operator to specify a constraint to select the objects where
  # the value of a field do not equal any value in the specified array.
  notIn: [ID!]
  # This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist).
  exists: Boolean
  # This is the inQueryKey operator to specify a constraint to select the objects
  # where a field equals to a key in the result of a different query.
  inQueryKey: SelectInput
  # This is the notInQueryKey operator to specify a constraint to select the
  # objects where a field do not equal to a key in the result of a different query.
  notInQueryKey: SelectInput
  # This is the inQuery operator to specify a constraint to select the objects
  # where a field equals to any of the ids in the result of a different query.
  inQuery: SubqueryInput
  # This is the notInQuery operator to specify a constraint to select the objects
  # where a field do not equal to any of the ids in the result of a different query.
  notInQuery: SubqueryInput
}

# Allow to add, remove, createAndAdd objects of the User class into a relation field.
input UserRelationInput {
  # Add an existing object from the User class into the relation.
  add: [ID!]
  # Remove an existing object from the User class out of the relation.
  remove: [ID!]
  # Create and add an object of the User class into the relation.
  createAndAdd: [CreateUserFieldsInput!]
}

# The UserWhereInput input type is used in operations that involve filtering objects of User class.
input UserWhereInput {
  # This is the object createdAt.
  createdAt: DateWhereInput
  # This is the object updatedAt.
  updatedAt: DateWhereInput
  # This is the object ACL.
  ACL: ObjectWhereInput
  # This is the object username.
  username: StringWhereInput
  # This is the object password.
  password: StringWhereInput
  # This is the object email.
  email: StringWhereInput
  # This is the object emailVerified.
  emailVerified: BooleanWhereInput
  # This is the object authData.
  authData: ObjectWhereInput
  # This is the object id.
  id: StringWhereInput
  # This is the OR operator to compound constraints.
  OR: [UserWhereInput!]
  # This is the AND operator to compound constraints.
  AND: [UserWhereInput!]
  # This is the NOR operator to compound constraints.
  NOR: [UserWhereInput!]
}

# The Viewer object type is used in operations that involve outputting the current user data.
type Viewer implements ParseObject {
  # This is the object id.
  id: ID!
  # This is the date in which the object was created.
  createdAt: Date!
  # This is the date in which the object was las updated.
  updatedAt: Date!
  # This is the access control list of the object.
  ACL: Object
  # This is the object username.
  username: String
  # This is the object email.
  email: String
  # This is the object emailVerified.
  emailVerified: Boolean
  # This is the object authData.
  authData: Object
  # The user session token
  sessionToken: String!
}

# The WithinInput type is used to specify a within operation on a constraint.
input WithinInput {
  # This is the box to be specified.
  box: BoxInput!
}

